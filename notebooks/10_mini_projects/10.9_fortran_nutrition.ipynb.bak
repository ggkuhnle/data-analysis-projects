{
  "cells": [
    {
      "cell_type": "markdown",
      "id": "9d2e3d3c",
      "metadata": {
        "tags": []
      },
      "source": [
        "# The Nutrition Rosetta Notebook â€” One Tiny Task, Many Languages ðŸ§ªðŸ§°\n",
        "\n",
        "*Last updated: 2025-09-14*\n",
        "\n",
        "We compute the same simple **nutritional index** in many programming languages to compare **idioms and paradigms**, not toolchains:\n",
        "\n",
        "> **Index = 0.4 Ã— Sugar + 0.6 Ã— SFA**  (lower = healthier)\n",
        "\n",
        "**How to read this notebook**\n",
        "- We create a small dataset and compute the reference result in **Python**.\n",
        "- Each subsequent section shows a language **snippet** (as a code fence) for the same task, plus short notes:\n",
        "  - What idioms/semantics it highlights (types, I/O, control, formatting).\n",
        "  - Where it fits today: **Alive**, **Historical**, or **Emerging**.\n",
        "- No compilation. No subprocesses. Just comparative pedagogy."
      ]
    },
    {
      "cell_type": "markdown",
      "id": "e7f6d7ed",
      "metadata": {
        "tags": []
      },
      "source": [
        "## 0) Tiny dataset + Python reference\n",
        "\n",
        "Two inputs per participant (Sugar, SFA), compute a linear index."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "56713574",
      "metadata": {
        "tags": []
      },
      "outputs": [],
      "source": [
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "data = pd.DataFrame({\n",
        "    'Participant': ['P1','P2','P3','P4','P5'],\n",
        "    'Sugar_Intake': [40,55,30,60,25],\n",
        "    'SFA_Intake':   [20,35,15,40,10]\n",
        "})\n",
        "\n",
        "data['Index'] = 0.4*data['Sugar_Intake'] + 0.6*data['SFA_Intake']\n",
        "data"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1e1bef37",
      "metadata": {
        "tags": []
      },
      "outputs": [],
      "source": [
        "plt.figure(figsize=(7,4))\n",
        "plt.bar(data['Participant'], data['Index'])\n",
        "plt.xlabel('Participant'); plt.ylabel('Index')\n",
        "plt.title('Reference results (Python)')\n",
        "plt.tight_layout(); plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "e78260a1",
      "metadata": {
        "tags": []
      },
      "source": [
        "\n",
        "## Legend: Where these languages fit today\n",
        "\n",
        "- **Alive**: actively used for scientific/numeric work.\n",
        "- **Historical**: mostly legacy/teaching; still instructive.\n",
        "- **Emerging**: growing adoption in science/HPC; worth watching."
      ]
    },
    {
      "cell_type": "markdown",
      "id": "43486ab0",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## FORTRAN 77 (fixed form) â€” ðŸŸ¡ Historical\n",
        "\n",
        "**Why include**  \n",
        "Shows the classic numeric style still found in legacy climate/epi codes.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- Fixed columns; implicit typing unless avoided.\n",
        "- DO loops; FORMAT statements; simple arrays.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "0a3e2268",
      "metadata": {
        "tags": []
      },
      "source": [
        "```fortran\n",
        "\n",
        "      PROGRAM NUTIDX\n",
        "      INTEGER I\n",
        "      REAL SUGAR(5), SFA(5), IDX(5)\n",
        "C     READ 5 LINES: SUGAR SFA\n",
        "      DO 10 I=1,5\n",
        "         READ(*,*) SUGAR(I), SFA(I)\n",
        "10    CONTINUE\n",
        "      DO 20 I=1,5\n",
        "         IDX(I) = 0.4*SUGAR(I) + 0.6*SFA(I)\n",
        "20    CONTINUE\n",
        "      DO 30 I=1,5\n",
        "         WRITE(*, '(F10.6)') IDX(I)\n",
        "30    CONTINUE\n",
        "      END\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "491f0a40",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## Fortran (2008+ free form) â€” ðŸŸ¢ Alive\n",
        "\n",
        "**Why include**  \n",
        "Still first-class for HPC kernels; clear array semantics and strong compilers.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- `implicit none`; explicit kinds; array loops or vectorised operations.\n",
        "- Simple, fast I/O; great for numerics.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "b4d5edf5",
      "metadata": {
        "tags": []
      },
      "source": [
        "```fortran\n",
        "\n",
        "program nutrition_index\n",
        "  implicit none\n",
        "  integer, parameter :: n=5\n",
        "  real :: sugar(n), sfa(n), idx(n)\n",
        "  integer :: i\n",
        "  do i=1,n\n",
        "     read(*,*) sugar(i), sfa(i)\n",
        "  end do\n",
        "  idx = 0.4*sugar + 0.6*sfa\n",
        "  do i=1,n\n",
        "     write(*,'(F0.6)') idx(i)\n",
        "  end do\n",
        "end program nutrition_index\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "463936e9",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## C (ISO C99) â€” ðŸŸ¢ Alive\n",
        "\n",
        "**Why include**  \n",
        "Ubiquitous systems language; many scientific libs expose a C ABI.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- `double` for numeric stability.\n",
        "- `fscanf/printf` for simple text I/O.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "e2851300",
      "metadata": {
        "tags": []
      },
      "source": [
        "```c\n",
        "\n",
        "#include <stdio.h>\n",
        "int main(void){\n",
        "  double sugar, sfa, idx;\n",
        "  for (int i=0;i<5;i++){\n",
        "    if (scanf(\"%lf %lf\", &sugar, &sfa)!=2) return 1;\n",
        "    idx = 0.4*sugar + 0.6*sfa;\n",
        "    printf(\"%.6f\\n\", idx);\n",
        "  }\n",
        "  return 0;\n",
        "}\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "d5b8f4c7",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## C++ (modern) â€” ðŸŸ¢ Alive\n",
        "\n",
        "**Why include**  \n",
        "Used in simulation engines and performance-critical code; strong libraries.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- `iostream` or `scanf/printf` interop; vectors; RAII; templates if needed.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "085f61c5",
      "metadata": {
        "tags": []
      },
      "source": [
        "```cpp\n",
        "\n",
        "#include <iostream>\n",
        "#include <vector>\n",
        "#include <iomanip>\n",
        "int main(){\n",
        "  std::vector<double> idx; idx.reserve(5);\n",
        "  for(int i=0;i<5;i++){\n",
        "    double sugar, sfa;\n",
        "    if(!(std::cin>>sugar>>sfa)) return 1;\n",
        "    idx.push_back(0.4*sugar + 0.6*sfa);\n",
        "  }\n",
        "  std::cout<<std::fixed<<std::setprecision(6);\n",
        "  for(double v: idx) std::cout<<v<<\"\\n\";\n",
        "}\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "322acc66",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## Python â€” ðŸŸ¢ Alive\n",
        "\n",
        "**Why include**  \n",
        "De facto language for analysis, ML, and glue code.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- High-level, batteries-included; vectorised with NumPy/Pandas.\n",
        "- Easy plotting and I/O.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "4be563b1",
      "metadata": {
        "tags": []
      },
      "source": [
        "```python\n",
        "\n",
        "import sys\n",
        "for line in sys.stdin:\n",
        "    sugar, sfa = map(float, line.split())\n",
        "    idx = 0.4*sugar + 0.6*sfa\n",
        "    print(f\"{idx:.6f}\")\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "ed64e4d7",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## R â€” ðŸŸ¢ Alive\n",
        "\n",
        "**Why include**  \n",
        "Statistics, epidemiology, bioinformatics; great for data frames and models.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- `read.table`/`data.frame`; vectorised arithmetic; `write.table`.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "52a43f47",
      "metadata": {
        "tags": []
      },
      "source": [
        "```r\n",
        "\n",
        "x <- read.table(\"intakes.txt\", col.names=c(\"sugar\",\"sfa\"))\n",
        "idx <- 0.4*x$sugar + 0.6*x$sfa\n",
        "write.table(format(idx, digits=6, nsmall=6), row.names=FALSE, col.names=FALSE, quote=FALSE)\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "a781066d",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## MATLAB / Octave â€” ðŸŸ¢ Alive\n",
        "\n",
        "**Why include**  \n",
        "Engineering, signal processing, and teaching; strong matrix semantics.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- Load text via `dlmread`/`readmatrix`; vectorised compute; formatted print.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "128958d0",
      "metadata": {
        "tags": []
      },
      "source": [
        "```matlab\n",
        "\n",
        "X = readmatrix('intakes.txt');  % columns: sugar sfa\n",
        "idx = 0.4*X(:,1) + 0.6*X(:,2);\n",
        "fprintf('%.6f\\n', idx);\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "04e33f9a",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## Julia â€” ðŸŸ£ Emerging\n",
        "\n",
        "**Why include**  \n",
        "Promises Python-like ergonomics with JIT speed; growing numerical community.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- Broadcasting `.*`; multiple dispatch; strong numeric libraries.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "4727a3d1",
      "metadata": {
        "tags": []
      },
      "source": [
        "```julia\n",
        "\n",
        "X = readdlm(\"intakes.txt\")\n",
        "sugar = X[:,1]; sfa = X[:,2]\n",
        "idx = 0.4 .* sugar .+ 0.6 .* sfa\n",
        "for v in idx\n",
        "    @printf(\"%.6f\\n\", v)\n",
        "end\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "241eb60e",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## Rust â€” ðŸŸ£ Emerging\n",
        "\n",
        "**Why include**  \n",
        "Memory safety + performance; increasingly used for HPC back-ends and data tooling.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- Ownership/borrowing; explicit parsing; strong tooling.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "d0b2c70f",
      "metadata": {
        "tags": []
      },
      "source": [
        "```rust\n",
        "\n",
        "use std::io::{self, Read};\n",
        "fn main(){\n",
        "    let mut s = String::new();\n",
        "    io::stdin().read_to_string(&mut s).unwrap();\n",
        "    for line in s.lines(){\n",
        "        let parts: Vec<f64> = line.split_whitespace().map(|t| t.parse().unwrap()).collect();\n",
        "        let idx = 0.4*parts[0] + 0.6*parts[1];\n",
        "        println!(\"{:.6}\", idx);\n",
        "    }\n",
        "}\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "af6f3c06",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## Go â€” ðŸŸ£ Emerging\n",
        "\n",
        "**Why include**  \n",
        "Great for distributed systems and pipelines; numerics improving via gonum.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- Simple concurrency; basic I/O; floats default to 64-bit literals.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "49e81c32",
      "metadata": {
        "tags": []
      },
      "source": [
        "```go\n",
        "\n",
        "package main\n",
        "import (\n",
        "  \"bufio\"; \"fmt\"; \"os\"\n",
        ")\n",
        "func main(){\n",
        "  in := bufio.NewScanner(os.Stdin)\n",
        "  for in.Scan(){\n",
        "    var sugar, sfa float64\n",
        "    fmt.Sscan(in.Text(), &sugar, &sfa)\n",
        "    idx := 0.4*sugar + 0.6*sfa\n",
        "    fmt.Printf(\"%.6f\\n\", idx)\n",
        "  }\n",
        "}\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "d6721a70",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## Chapel â€” ðŸŸ£ Emerging\n",
        "\n",
        "**Why include**  \n",
        "Parallel programming from Cray/HPE; aims to simplify distributed/HPC.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- High-level arrays; `writeln` formatting.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "10dfaa77",
      "metadata": {
        "tags": []
      },
      "source": [
        "```chapel\n",
        "\n",
        "use IO;\n",
        "var sugar, sfa: real;\n",
        "for i in 1..5 {\n",
        "  stdin.readf(\"%r %r\\n\", sugar, sfa);\n",
        "  const idx = 0.4*sugar + 0.6*sfa;\n",
        "  writeln(idx:0:6);\n",
        "}\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "461fef3a",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## D â€” ðŸŸ£ Emerging\n",
        "\n",
        "**Why include**  \n",
        "A systems language with high-level features; some numeric use in HPC.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- Ranges, strong standard library, C interop.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c01519fb",
      "metadata": {
        "tags": []
      },
      "source": [
        "```d\n",
        "\n",
        "import std.stdio, std.string;\n",
        "void main(){\n",
        "  string line;\n",
        "  foreach(i; 0..5){\n",
        "    if(!stdin.readln(line)) return;\n",
        "    auto parts = line.split();\n",
        "    double sugar = parts[0].to!double;\n",
        "    double sfa   = parts[1].to!double;\n",
        "    double idx = 0.4*sugar + 0.6*sfa;\n",
        "    writefln(\"%.6f\", idx);\n",
        "  }\n",
        "}\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "dc55df63",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## F# â€” ðŸŸ£ Emerging\n",
        "\n",
        "**Why include**  \n",
        "Functional-first on .NET; used in quantitative finance and some modelling.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- Pipelining; immutable by default; .NET I/O.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "a497c308",
      "metadata": {
        "tags": []
      },
      "source": [
        "```fsharp\n",
        "\n",
        "open System\n",
        "[1..5] |> List.iter (fun _ ->\n",
        "    let line = Console.ReadLine()\n",
        "    let parts = line.Split([|' '|], StringSplitOptions.RemoveEmptyEntries) |> Array.map float\n",
        "    let idx = 0.4*parts[0] + 0.6*parts[1]\n",
        "    printfn \"%.6f\" idx\n",
        ")\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "e2f1ff85",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## OCaml â€” ðŸŸ£ Emerging\n",
        "\n",
        "**Why include**  \n",
        "Functional with strong type inference; used in verification and some numerics.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- Pattern matching; modules; straightforward I/O.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "5495995f",
      "metadata": {
        "tags": []
      },
      "source": [
        "```ocaml\n",
        "\n",
        "let () =\n",
        "  try\n",
        "    for i = 1 to 5 do\n",
        "      let line = read_line () in\n",
        "      let parts = Array.of_list (String.split_on_char ' ' line) in\n",
        "      let sugar = float_of_string parts.(0) in\n",
        "      let sfa   = float_of_string parts.(1) in\n",
        "      let idx = 0.4 *. sugar +. 0.6 *. sfa in\n",
        "      Printf.printf \"%.6f\\n\" idx\n",
        "    done\n",
        "  with End_of_file -> ()\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "4d3765ac",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## Common Lisp â€” ðŸŸ¡ Historical\n",
        "\n",
        "**Why include**  \n",
        "Symbolic AI heritage; still used in some research/DSLs.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- S-expressions; read/print; numeric types.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "353c38e3",
      "metadata": {
        "tags": []
      },
      "source": [
        "```lisp\n",
        "\n",
        "(loop for i from 1 to 5 do\n",
        "  (let* ((line (read-line *standard-input* nil))\n",
        "         (parts (uiop:split-string line))\n",
        "         (sugar (parse-number:parse-number (first parts)))\n",
        "         (sfa   (parse-number:parse-number (second parts)))\n",
        "         (idx (+ (* 0.4 sugar) (* 0.6 sfa))))\n",
        "    (format t \"~,6f~%\" idx)))\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "ba148bf5",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## Scheme (Racket/Guile) â€” ðŸŸ¡ Historical\n",
        "\n",
        "**Why include**  \n",
        "Lisp family; elegant minimal core; good for teaching.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- Prefix notation; exact vs inexact numbers; I/O ports.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "58c71b90",
      "metadata": {
        "tags": []
      },
      "source": [
        "```scheme\n",
        "\n",
        "(do ((i 0 (+ i 1))) ((= i 5))\n",
        "  (let* ((line (read-line))\n",
        "         (parts (string-split line))\n",
        "         (sugar (string->number (list-ref parts 0)))\n",
        "         (sfa   (string->number (list-ref parts 1)))\n",
        "         (idx (+ (* 0.4 sugar) (* 0.6 sfa))))\n",
        "    (printf \"~a~n\" (real->decimal-string idx 6))))\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "6425f8c9",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## Ada â€” ðŸŸ£ Emerging\n",
        "\n",
        "**Why include**  \n",
        "Used in aerospace/safety-critical; strong typing and contracts (SPARK).\n",
        "\n",
        "**Idioms to notice**  \n",
        "- Decimal types; explicit I/O; range checks.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "cb1880bd",
      "metadata": {
        "tags": []
      },
      "source": [
        "```ada\n",
        "\n",
        "with Ada.Text_IO; use Ada.Text_IO;\n",
        "procedure Nutrition_Index is\n",
        "  Sugar, SFA : Float;\n",
        "  Idx: Float;\n",
        "begin\n",
        "  for I in 1 .. 5 loop\n",
        "    declare\n",
        "      Line : String := Get_Line;\n",
        "      Pos  : Integer := Line'First;\n",
        "    begin\n",
        "      -- naive split on space\n",
        "      null; -- parsing omitted for brevity\n",
        "    end;\n",
        "    Idx := 0.4*Sugar + 0.6*SFA;\n",
        "    Put_Line (Float'Image(Idx));\n",
        "  end loop;\n",
        "end Nutrition_Index;\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "332721be",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## Pascal â€” ðŸŸ¡ Historical\n",
        "\n",
        "**Why include**  \n",
        "Structured programming classic; clean teaching language.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- Typed vars; `readln`/`writeln`; simple arithmetic.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "b82196ac",
      "metadata": {
        "tags": []
      },
      "source": [
        "```pascal\n",
        "\n",
        "program NutritionIndex;\n",
        "var i: integer; sugar, sfa, idx: real;\n",
        "begin\n",
        "  for i:=1 to 5 do\n",
        "  begin\n",
        "    readln(sugar, sfa);\n",
        "    idx := 0.4*sugar + 0.6*sfa;\n",
        "    writeln(idx:0:6);\n",
        "  end;\n",
        "end.\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "51bc1334",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## Forth â€” ðŸŸ¡ Historical\n",
        "\n",
        "**Why include**  \n",
        "Stack-based minimalist; different mental model.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- Concatenative words; stack ops; floats as an extension.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "ac5bacee",
      "metadata": {
        "tags": []
      },
      "source": [
        "```forth\n",
        "\n",
        ": one-index  ( -- )\n",
        "  BL WORD >NUMBER 2DROP S>F   \\ sugar\n",
        "  BL WORD >NUMBER 2DROP S>F   \\ sfa\n",
        "  0.4E F*  SWAP  0.6E F*  F+  F. ;\n",
        ": main ( -- ) 5 0 DO one-index LOOP ;\n",
        "main\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "e132c785",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## COBOL â€” ðŸŸ¡ Historical\n",
        "\n",
        "**Why include**  \n",
        "Record/ledger heritage; interesting for I/O semantics.\n",
        "\n",
        "**Idioms to notice**  \n",
        "- PICTURE clauses; line-sequential files; verbose data handling.\n",
        "\n",
        "**Snippet**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "1e0de2ac",
      "metadata": {
        "tags": []
      },
      "source": [
        "```cobol\n",
        "\n",
        "       IDENTIFICATION DIVISION.\n",
        "       PROGRAM-ID. NUTRITION-INDEX.\n",
        "       DATA DIVISION.\n",
        "       WORKING-STORAGE SECTION.\n",
        "       01 SUGAR     PIC 9(3).\n",
        "       01 SFA       PIC 9(3).\n",
        "       01 IDX       PIC 9(3)V9(6).\n",
        "       PROCEDURE DIVISION.\n",
        "           PERFORM VARYING IDX FROM 1 BY 1 UNTIL IDX > 5\n",
        "              ACCEPT SUGAR SFA\n",
        "              COMPUTE IDX = 0.4 * SUGAR + 0.6 * SFA\n",
        "              DISPLAY FUNCTION FORMAT(IDX, \"999.999999\")\n",
        "           END-PERFORM\n",
        "           STOP RUN.\n",
        "\n",
        "```"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "25d61d49",
      "metadata": {
        "tags": []
      },
      "source": [
        "<hr />\n",
        "## Closing comparison\n",
        "\n",
        "- **Alive**: Fortran (modern), C/C++, Python, R, MATLAB/Octave, Julia (growing), Rust (growing).  \n",
        "- **Historical**: FORTRAN 77, Pascal, COBOL, Forth, Lisp/Scheme (for numerics).  \n",
        "- **Emerging**: Julia, Rust, Go, Chapel, D, F#, OCaml, Ada (safety-critical niche).\n",
        "\n",
        "### Exercises\n",
        "1. For three languages from different categories, explain how **types + I/O** shape the snippet (e.g., COBOLâ€™s PICTURE vs Câ€™s `scanf`).  \n",
        "2. Extend the Python dataset to 100 rows and consider **precision/formatting** issues across languages.  \n",
        "3. Sketch how youâ€™d wrap a Fortran or C implementation as a **shared library** for Python (no compilation needed hereâ€”just the API surface).\n",
        "\n",
        "Remember: the goal is to recognise **paradigms**, not to memorise syntax. Choose tools that match your problem, team, and constraints."
      ]
    }
  ],
  "metadata": {
    "authors": [
      {
        "name": "Prepared for Gunter's course"
      }
    ],
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}